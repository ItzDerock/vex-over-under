<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>My Project</title>

  <!-- PrismJS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism-coy.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.css" />

  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 8px;
    }
    pre {
      margin: 0;
    }

    code {
      font-family: monospace;
    }

    h1 {
      margin-top: 1rem;
      margin-bottom: 0.25rem;
    }

    p {
      margin-top: 0.25rem;
      margin-bottom: 0.25rem;
    }

    pre[class*="language-"] {
      max-height: inherit !important;
      overflow: hidden !important;

      box-shadow: none !important;
      border-left: none !important;
    }

    code[class*="language"] {
      overflow: hidden !important;
    }
  </style>
</head>
<body>
<h1 id="vex-2023---over-under-code">VEX 2023 - Over Under Code</h1>
<p>This repository holds the C++ code for KCDâ€™s VEX 2023 Over Under
robot (95993A).</p>
<h2 id="features">Features:</h2>
<ul>
<li>Simple tank drive controls</li>
<li>3 wheel odometry system
<ul>
<li>uses 2 internal encoders</li>
<li>1 exterior encoder for lateral movement</li>
</ul></li>
<li>PID Control</li>
<li>Catapult control
<ul>
<li>Rotational sensor to read position</li>
<li>Single press to fire once</li>
<li>Hold for rapid fire</li>
</ul></li>
<li>Wings toggle</li>
<li>GIF decoder
<ul>
<li>Plays a gif on the brain screen using LVGL and a simple gifdecoder
library</li>
</ul></li>
</ul>
<h2 id="ports">Ports:</h2>
<p>See [src/config.hpp] for the port configuration. Can be easily edited
to accomodate broken ports.</p>
<h2 id="technology-used">Technology Used:</h2>
<p>PROSv5 - C++ API to interface with the VEX hardware LVGL - C library
for graphics rendering on the brain screen gifdec - C library for
decoding gifs</p>
<h2 id="utility-programs">Utility Programs:</h2>
<ul>
<li><code>scripts/htmlify.sh</code> - Converts all source files
(controlled by a list containing glob patterns) to one large HTML file
so you can export and paste into your design notebook.</li>
</ul>
<hr>
<h1>./src/config.cpp</h1>
<p><strong>Last commit:</strong> wip: odom (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
/**
 * This file just defines the global variables declared in config.hpp.
 * Please edit config.hpp instead of this file for port changes.
 */

#include &quot;config.hpp&quot;

#include &quot;pros/adi.hpp&quot;
#include &quot;pros/rotation.hpp&quot;

#define SHARED(type, name, ...) \
  std::shared_ptr&lt;type&gt; name = std::make_shared&lt;type&gt;(__VA_ARGS__)

SHARED(pros::Motor, drive_left_front, DRIVE_LEFT_FRONT,
       pros::v5::MotorGear::blue);
SHARED(pros::Motor, drive_left_back, DRIVE_LEFT_BACK,
       pros::v5::MotorGear::blue);
SHARED(pros::Motor, drive_left_pto, -DRIVE_LEFT_PTO, pros::v5::MotorGear::blue);
SHARED(pros::Motor, drive_right_front, -DRIVE_RIGHT_FRONT,
       pros::v5::MotorGear::blue);
SHARED(pros::Motor, drive_right_back, -DRIVE_RIGHT_BACK,
       pros::v5::MotorGear::blue);
SHARED(pros::Motor, drive_right_pto, DRIVE_RIGHT_PTO,
       pros::v5::MotorGear::blue);

OdomIntegratedSensor odom_left = {
    .sensor = drive_left_back,
    .offset = 0,
};

OdomIntegratedSensor odom_right = {
    .sensor = drive_right_back,
    .offset = 0,
};

OdomSensor odom_middle = {
    .sensor = std::make_shared&lt;pros::adi::Encoder&gt;(ODOM_MIDDLE_PORT),
    .offset = 0,
};

std::vector&lt;pros::Motor&gt; drive_left_v = {*drive_left_front, *drive_left_back};

std::vector&lt;pros::Motor&gt; drive_right_v = {*drive_right_front,
                                          *drive_right_back};

SHARED(pros::Motor, catapult_motor, CATAPULT_PORT, pros::v5::MotorGear::red);
SHARED(pros::Rotation, catapult_position, CATAPULT_ROT_PORT);
SHARED(pros::adi::Pneumatics, wings, WINGS_PORT, false);

#undef SHARED</code></pre>
<h1>./src/config.hpp</h1>
<p><strong>Last commit:</strong> wip: odom (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#pragma once
#include &quot;main.h&quot;
#include &quot;pros/adi.hpp&quot;

// ODOMETRY
#define ODOMETRY_TICKS_PER_INCH 360.0  // ticks per inch
#define ODOMETRY_WHEEL_DIAMETER 2.75   // inches
#define ODOM_MIDDLE_PORT &#39;b&#39;, &#39;c&#39;

// DRIVETRAIN
#define DRIVETRAIN_GEAR_RATIO /* input 32 -&gt; output 72 */ 0.5
#define DRIVE_LEFT_FRONT 1
#define DRIVE_LEFT_BACK 2
#define DRIVE_LEFT_PTO 3
#define DRIVE_RIGHT_FRONT 4
#define DRIVE_RIGHT_BACK 5
#define DRIVE_RIGHT_PTO 6

// CATAPULT
#define CATAPULT_PORT 15
#define CATAPULT_ROT_PORT 10

// WINGS
#define WINGS_PORT &#39;a&#39;

/*************************
 * VARIABLE DECLARATIONS *
 *************************/

// useful macro for quickly defining a shared_ptr
#define SHARED(type, name) std::shared_ptr&lt;type&gt; name

//// Odometry

struct OdomSensor {
  SHARED(pros::adi::Encoder, sensor);
  double offset;
};

struct OdomIntegratedSensor {
  SHARED(pros::Motor, sensor);
  double offset;
  double gear_ratio;
};

// odometry sensors
// no need to use shared pointers
extern OdomIntegratedSensor odom_left;
extern OdomIntegratedSensor odom_right;
extern OdomSensor odom_middle;

//// Drivetrain
extern SHARED(pros::Motor, drive_left_front);
extern SHARED(pros::Motor, drive_left_back);
extern SHARED(pros::Motor, drive_left_pto);
extern SHARED(pros::Motor, drive_right_front);
extern SHARED(pros::Motor, drive_right_back);
extern SHARED(pros::Motor, drive_right_pto);

extern pros::MotorGroup drive_left;
extern pros::MotorGroup drive_right;

//// Catapult
extern SHARED(pros::Motor, catapult_motor);
extern SHARED(pros::Rotation, catapult_position);

///// Wings
extern SHARED(pros::adi::Pneumatics, wings);

// undefine SHARED macro to prevent accidental use
#undef SHARED</code></pre>
<h1>./src/main.cpp</h1>
<p><strong>Last commit:</strong> wip: odom (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#include &quot;main.h&quot;

#include &quot;config.hpp&quot;
#include &quot;gif-pros/gifclass.hpp&quot;
#include &quot;odom/odom.hpp&quot;
#include &quot;pros/misc.h&quot;
#include &quot;screen/screen.hpp&quot;
#include &quot;subsystems/subsystems.hpp&quot;

/**
 * Runs initialization code. This occurs as soon as the program is started.
 *
 * All other competition modes are blocked by initialize; it is recommended
 * to keep execution time for this mode under a few seconds.
 */
void initialize() {
  catapult::initialize();
  odom::init();
  static Gif gif(&quot;/usd/game.gif&quot;, lv_scr_act());
}

/**
 * Runs while the robot is in the disabled state of Field Management System or
 * the VEX Competition Switch, following either autonomous or opcontrol. When
 * the robot is enabled, this task will exit.
 */
void disabled() {}

/**
 * Runs after initialize(), and before autonomous when connected to the Field
 * Management System or the VEX Competition Switch. This is intended for
 * competition-specific initialization routines, such as an autonomous selector
 * on the LCD.
 *
 * This task will exit when the robot is enabled and autonomous or opcontrol
 * starts.
 */
void competition_initialize() {}

/**
 * Runs the user autonomous code. This function will be started in its own task
 * with the default priority and stack size whenever the robot is enabled via
 * the Field Management System or the VEX Competition Switch in the autonomous
 * mode. Alternatively, this function may be called in initialize or opcontrol
 * for non-competition testing purposes.
 *
 * If the robot is disabled or communications is lost, the autonomous task
 * will be stopped. Re-enabling the robot will restart the task, not re-start it
 * from where it left off.
 */
void autonomous() {}

/**
 * Runs the operator control code. This function will be started in its own task
 * with the default priority and stack size whenever the robot is enabled via
 * the Field Management System or the VEX Competition Switch in the operator
 * control mode.
 *
 * If no competition control is connected, this function will run immediately
 * following initialize().
 *
 * If the robot is disabled or communications is lost, the
 * operator control task will be stopped. Re-enabling the robot will restart the
 * task, not resume it from where it left off.
 */
void opcontrol() {
  pros::Controller master(pros::E_CONTROLLER_MASTER);

  while (true) {
    // get the joystick values
    int leftJoystick = master.get_analog(ANALOG_RIGHT_Y);
    int rightJoystick = master.get_analog(ANALOG_LEFT_Y);

    // update drive
    drive_left_back-&gt;move(leftJoystick);
    drive_left_front-&gt;move(leftJoystick);
    drive_left_pto-&gt;move(leftJoystick);
    drive_right_back-&gt;move(rightJoystick);
    drive_right_front-&gt;move(rightJoystick);
    drive_right_pto-&gt;move(rightJoystick);

    // if single press, fire once
    if (master.get_digital_new_press(DIGITAL_R1)) {
      catapult::fire();
    }
    // if held, rapid fire
    else if (master.get_digital(DIGITAL_R1)) {
      catapult::rapidFire = true;
    }
    // if released, stop rapid fire
    else {
      catapult::rapidFire = false;
    }

    // wings
    if (master.get_digital_new_press(DIGITAL_L1)) {
      wings-&gt;toggle();
    }

    pros::delay(10);
  }
}</code></pre>
<h1>./src/algorithms/PID.cpp</h1>
<p><strong>Last commit:</strong> feat: catapult (2023-11-20)</p>
<pre><code class="language-cpp line-numbers">
#include &quot;PID.hpp&quot;
#include &lt;cstdio&gt;

PIDController::PIDController(double kP, double kI, double kD)
    : _kP(kP), _kI(kI), _kD(kD), debug(false) {}

PIDController::PIDController(double kP, double kI, double kD, bool debug)
    : _kP(kP), _kI(kI), _kD(kD), debug(debug) {}

double PIDController::update(double error) {
  _integral += error;
  double derivative = error - _previousError;

  double kPOutput = _kP * error;
  double kIOutput = _kI * _integral;
  double kDOutput = _kD * derivative;

  if (debug)
    printf(&quot;err: %f, kP: %f, kI: %f, kD: %f\n&quot;, error, kPOutput, kIOutput,
           kDOutput);

  double output = kPOutput + kIOutput + kDOutput;

  _previousError = error;
  return output;
}

void PIDController::reset() {
  _previousError = 0;
  _integral = 0;

  if (debug)
    printf(&quot;PID reset&quot;);
}</code></pre>
<h1>./src/algorithms/PID.hpp</h1>
<p><strong>Last commit:</strong> feat: catapult (2023-11-20)</p>
<pre><code class="language-cpp line-numbers">
#pragma once

class PIDController {
public:
  PIDController(double kP, double kI, double kD);
  PIDController(double kP, double kI, double kD, bool debug);
  double update(double error);
  void reset();

private:
  bool debug;
  double _kP, _kI, _kD;
  double _previousError = 0;
  double _integral = 0;
};</code></pre>
<h1>./src/odom/odom.cpp</h1>
<p><strong>Last commit:</strong> wip: odom (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#include &quot;./odom.hpp&quot;

#include &lt;math.h&gt;

#include &quot;../config.hpp&quot;
#include &quot;main.h&quot;

/**
 * Odometry implementation is based on the following paper:
 * http://thepilons.ca/wp-content/uploads/2018/10/Tracking.pdf
 *
 * Movement functions are not based on that paper.
 */

std::shared_ptr&lt;PIDController&gt; odom::turnPID =
    std::make_shared&lt;PIDController&gt;(0.2, 0.01, 0.001);
std::shared_ptr&lt;PIDController&gt; odom::drivePID =
    std::make_shared&lt;PIDController&gt;(0.5, 0.01, 0.001);

// Task to update the odom
pros::Task *odomTask = nullptr;
pros::Mutex odom::mutex;

struct {
  double left, right, center, theta;
} prevSensors = {0, 0, 0, 0};

struct {
  double left, right, theta;
} resetValues = {0, 0, 0};

odom::RobotPosition state = {0, 0, 0};

/**
 * Since part of our odometry is based on internal sensors in the motors,
 * we need to normalize the data to account for different gear ratios.
 *
 * @param sensor The sensor to normalize
 */
double normalizeSensorData(OdomIntegratedSensor sensor) {
  // return sensor.sensor-&gt;get_position() * (1/sensor.gear_ratio) * 600 / 360;
  return sensor.sensor-&gt;get_position() * sensor.gear_ratio * 4 * M_PI;
}

void odom::update() {
  // lock mutex
  mutex.take();

  // 1. Store the current encoder values
  auto left = odom_left.sensor-&gt;get_position();
  auto right = odom_right.sensor-&gt;get_position();
  auto center = odom_middle.sensor-&gt;get_value() * 2.75 * M_PI;

  std::cout &lt;&lt; &quot;left: &quot; &lt;&lt; left &lt;&lt; std::endl;

  // 2. Calculate delta values
  auto dL = left - prevSensors.left;
  auto dR = right - prevSensors.right;
  auto dC = center - prevSensors.center;

  // 3. Update the previous values
  prevSensors.left = left;
  prevSensors.right = right;
  prevSensors.center = center;

  // 4. total change since last reset
  // auto deltaLr = left - resetValues.left;
  // auto deltaRr = right - resetValues.right;

  // 5. Calculate new orientation
  auto newTheta = resetValues.theta +
                  (left - right) / (odom_left.offset + odom_right.offset);

  // 6. Calculate change in orientation
  auto dTheta = newTheta - state.theta;

  // 7. Calculate local offset for dTheta = 0
  RobotPosition localOffset = {0, 0, 0};

  if (dTheta == 0) {
    localOffset.x = dC;
    localOffset.y = dR;
  } else {
    // 8. Otherwise, calculate local offset with formula.
    localOffset.x = 2 * sin(dTheta / 2) * (dC / dTheta + (odom_middle.offset));
    localOffset.y = 2 * sin(dTheta / 2) * (dR / dTheta + (odom_right.offset));
  }

  // 9. Calculate the average orientation
  auto thetam = state.theta + dTheta / 2;

  // 10. Calculate the global offset
  RobotPosition globalOffset = {0, 0, 0};
  // int globalOffsetX = 0;
  // int globalOffsetY = 0;

  // convert local offset to polar coordinates
  double r =
      sqrt(localOffset.x * localOffset.x + localOffset.y * localOffset.y);
  double theta = atan2(localOffset.y, localOffset.x);

  // subtract thetam from the angle component
  theta -= thetam;

  // convert back to Cartesian coordinates
  globalOffset.x = r * cos(theta);
  globalOffset.y = r * sin(theta);

  // 11. Update the global position
  state.x += globalOffset.x;
  state.y += globalOffset.y;

  state.theta = newTheta;

  std::cout &lt;&lt; &quot;x: &quot; &lt;&lt; state.x &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;y: &quot; &lt;&lt; state.y &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;theta: &quot; &lt;&lt; state.theta &lt;&lt; std::endl;

  // unlock mutex
  mutex.give();
}

void odom::init() {
  if (odomTask != nullptr) {
    std::cout &lt;&lt; &quot;WARNING: odom::init() called when odomTask is not null&quot;
              &lt;&lt; std::endl;
    return;
  }

  odomTask = new pros::Task([]() {
    while (true) {
      update();
      pros::delay(20);
    }
  });
}

void odom::reset(odom::RobotPosition startState) {
  // aquire mutex
  mutex.take();

  // stop task
  if (odomTask != nullptr) {
    odomTask-&gt;remove();
    odomTask = nullptr;
  }

  // reset encoders
  // TODO: fix
  // odom_left.sensor-&gt;reset();
  // odom_right.sensor-&gt;reset();
  odom_middle.sensor-&gt;reset();

  // reset state
  // state = startState;
  state.x = startState.x;
  state.y = startState.y;
  state.theta = startState.theta;
  resetValues.theta = startState.theta;

  // reset prevSensors
  prevSensors = {0, 0, 0, 0};

  // restart task
  init();

  // release mutex
  mutex.give();
}

void odom::reset() {
  // default to 0, 0, 0
  reset({0, 0, 0});
}

odom::RobotPosition odom::getPosition(bool degrees) {
  // aquire mutex
  mutex.take();

  // get the state
  RobotPosition returnState =
      degrees ? RobotPosition(state.x, state.y, state.theta * (180 / M_PI))
              : state;

  // release mutex
  mutex.give();

  // return the state
  return returnState;
}

odom::RobotPosition odom::getPosition() { return getPosition(false); }

void odom::turnTo(double theta) {
  // aquire mutex
  mutex.take();

  // get the current theta
  double currentTheta = state.theta;

  // release mutex
  mutex.give();

  // calculate the error
  double error = theta - currentTheta;

  // if error is greater than 180, subtract 360
  if (error &gt; 180) error -= 360;
  // if error is less than -180, add 360
  else if (error &lt; -180)
    error += 360;

  // while the error is greater than the allowed error
  while (fabs(error) &gt; 0.5) {
    // aquire mutex
    mutex.take();

    // get the current theta
    currentTheta = state.theta;

    // release mutex
    mutex.give();

    // calculate the error
    error = theta - currentTheta;

    // if error is greater than 180, subtract 360
    if (error &gt; 180) error -= 360;
    // if error is less than -180, add 360
    else if (error &lt; -180)
      error += 360;

    // calculate the output
    double output = odom::turnPID-&gt;update(error);

    // set the motors
    drive_left_back-&gt;move(output);
    drive_left_front-&gt;move(output);
    drive_left_pto-&gt;move(output);
    drive_right_back-&gt;move(-output);
    drive_right_front-&gt;move(-output);
    drive_right_pto-&gt;move(-output);

    // wait
    pros::delay(20);
  }

  // stop the motors
  drive_left_back-&gt;move(0);
  drive_left_front-&gt;move(0);
  drive_left_pto-&gt;move(0);
  drive_right_back-&gt;move(0);
  drive_right_front-&gt;move(0);
  drive_right_pto-&gt;move(0);
}</code></pre>
<h1>./src/odom/odom.hpp</h1>
<p><strong>Last commit:</strong> wip: odom (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#pragma once
#include &quot;../algorithms/PID.hpp&quot;
#include &quot;main.h&quot;

namespace odom {

struct RobotPosition {
  double x;
  double y;
  double theta;

  int getDegrees() { return (int)(theta * 180 / M_PI); }
  RobotPosition(double x, double y, double theta) : x(x), y(y), theta(theta) {}
};

/**
 * PID controller for odom-related tasks.
 */
extern std::shared_ptr&lt;PIDController&gt; turnPID;
extern std::shared_ptr&lt;PIDController&gt; drivePID;

/**
 * Returns the current robot location, by default in radians.
 */
RobotPosition getPosition(bool degrees);
RobotPosition getPosition();

/**
 * Updates the odoemtry position
 */
void update();

/**
 * Resets the odometry to a given position.
 */
void reset(RobotPosition startState);
void reset();

/**
 * Initializes the odometry task.
 */
void init();

/**
 * turn to a given angle
 */
void turnTo(double theta);

/**
 * The odometry mutex. Use whenever you are reading values.
 */
extern pros::Mutex mutex;

}  // namespace odom</code></pre>
<h1>./src/screen/field.cpp</h1>
<p><strong>Last commit:</strong> feat: catapult (2023-11-20)</p>
<pre><code class="language-cpp line-numbers">
#include &quot;../odom/odom.hpp&quot;
#include &quot;screen.hpp&quot;

// The width of the field in inches (for use in converting inches to pixels)
const double FIELD_WIDTH_INCHES = 147.8377757;

// the width/height of the robot indicator in pixels
const int ROBOT_INDICATOR_SIZE = 15;

// load the field and robot image
LV_IMG_DECLARE(FIELD_BACKGROUND);
LV_IMG_DECLARE(ROBOT_IMAGE);

/**
 * Converts inches to pixels.
 *
 * @param[in] inches The number of inches to convert.
 * @param[in] imageWidth The width of the image in pixels.
 * @return The number of pixels that corresponds to the given number of inches.
 */
inline double inchesToPixels(double inches, double imageWidth) {
  return inches / FIELD_WIDTH_INCHES * imageWidth;
}

void screen::FieldWindow::init() {
  // create the images
  fieldImage = lv_img_create(this-&gt;lvObj);
  lv_img_set_src(fieldImage, &amp;FIELD_BACKGROUND);

  robotImage = lv_img_create(this-&gt;lvObj);
  lv_img_set_src(robotImage, &amp;ROBOT_IMAGE);

  // set the size of the images
  lv_obj_set_size(fieldImage, width, height);
  lv_obj_set_size(robotImage, ROBOT_INDICATOR_SIZE, ROBOT_INDICATOR_SIZE);

  // set the position of the robot image
  lv_obj_set_pos(robotImage, 0, 0);
  lv_obj_set_pos(robotImage, 0, 0);
}

void screen::FieldWindow::tick() {
  // get the robot&#39;s position
  auto position = odom::getPosition();

  // convert the position to pixels
  double x = inchesToPixels(position.x, width);
  double y = inchesToPixels(position.y, height);

  // set the position of the robot image
  lv_obj_set_pos(robotImage, x - ROBOT_INDICATOR_SIZE / 2.0,
                 height - y - ROBOT_INDICATOR_SIZE / 2.0);
}</code></pre>
<h1>./src/screen/gif.cpp</h1>
<p><strong>Last commit:</strong> feat: gifs (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#include &quot;gif-pros/gifclass.hpp&quot;

/**
 * MIT License
 * Copyright (c) 2019 Theo Lemay
 * https://github.com/theol0403/gif-pros
 *
 * Heavily modified to support a newer version of gifdec.h
 * by Derock X. (derock@derock.dev)
 * https://github.com/ItzDerock/gif-pros
 */

/**
 * Construct the Gif class
 * An abstraction over gifdec.h
 *
 * @param fname  the gif filename on the SD card (prefixed with /usd/)
 * @param parent the LVGL parent object
 */
Gif::Gif(const char *fname, lv_obj_t *parent) {
  // 1. Open the gif file
  _gif = gd_open_gif(fname);

  if (_gif == NULL) {
    std::cerr &lt;&lt; &quot;Gif::Gif - error opening \&quot;&quot; + std::string(fname) + &quot;\&quot;&quot;
              &lt;&lt; std::endl;
    return;
  }

  // 1.1 Optional: print out gif info
  std::cout &lt;&lt; &quot;Gif::Gif - \&quot;&quot; &lt;&lt; fname &lt;&lt; &quot;\&quot; info:&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;  width: &quot; &lt;&lt; _gif-&gt;width &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;  height: &quot; &lt;&lt; _gif-&gt;height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;  colors: &quot; &lt;&lt; _gif-&gt;palette-&gt;size &lt;&lt; std::endl;

  // 2. Allocate memory for current frame
  _buffer = new uint8_t[_gif-&gt;width * _gif-&gt;height * 3];
  _cbuf = new lv_color_t[_gif-&gt;width * _gif-&gt;height];
  _canvas = lv_canvas_create(parent);
  lv_canvas_set_buffer(_canvas, _cbuf, _gif-&gt;width, _gif-&gt;height,
                       LV_IMG_CF_TRUE_COLOR_ALPHA);

  std::cout &lt;&lt; &quot;  canvas: &quot; &lt;&lt; _canvas &lt;&lt; std::endl;

  // 3. Create task to render gif
  _task = pros::c::task_create(
      _render_task, this, TASK_PRIORITY_DEFAULT - 2, TASK_STACK_DEPTH_DEFAULT,
      (&quot;GIF - \&quot;&quot; + std::string(fname) + &quot;\&quot;&quot;).c_str());
};

/**
 * Destructs and cleans the Gif class
 */
Gif::~Gif() { _cleanup(); }

/**
 * Pauses the GIF task
 */
void Gif::pause() { pros::c::task_suspend(_task); }

/**
 * Resumes the GIF task
 */
void Gif::resume() { pros::c::task_resume(_task); }

/**
 * Deletes GIF and frees all allocated memory
 */
void Gif::clean() { _cleanup(); }

/**
 * Cleans and frees all allocated memory
 */
void Gif::_cleanup() {
  if (_canvas) {
    lv_obj_del(_canvas);
    _canvas = nullptr;
  }
  if (_cbuf) {
    delete[] _cbuf;
    _cbuf = nullptr;
  }
  if (_buffer) {
    free(_buffer);
    _buffer = nullptr;
  }
  if (_gif) {
    gd_close_gif(_gif);
    _gif = nullptr;
  }
  // deleting task kills this thread
  if (_task) {
    pros::c::task_delete(_task);
    _task = nullptr;
  }
}

/**
 * Render cycle, blocks until loop count exceeds gif loop count flag (if any)
 */
void Gif::_render() {
  for (size_t looped = 1;; looped++) {
    while (gd_get_frame(_gif)) {
      auto now = pros::millis();

      gd_render_frame(_gif, _buffer);

      auto renderdone = pros::millis();
      if (renderdone - now &gt; 10) {
        std::cerr &lt;&lt; &quot;Gif::_render - frame render took longer than 10ms. Took &quot;
                  &lt;&lt; pros::millis() - now &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;
      }

      uint8_t *color = _buffer;  // uint8_t[3] pointer
      for (size_t i = 0; i &lt; _gif-&gt;height * _gif-&gt;width; i++) {
        // check for transparency
        // in gifs, there are no partial transparency, only fully
        // transparent or fully opaque
        _cbuf[i].ch.alpha =
            gd_is_bgcolor(_gif, color) ? LV_OPA_TRANSP : LV_OPA_COVER;

        // break the 24-bit color into 8-bit channels
        // deref then increment pointer
        _cbuf[i].ch.red = *color++;
        _cbuf[i].ch.green = *color++;
        _cbuf[i].ch.blue = *color++;
      };

      if (pros::millis() - renderdone &gt; 10) {
        std::cerr &lt;&lt; &quot;Gif::_render - frame conversion took longer than 10ms. &quot;
                  &lt;&lt; &quot;Took &quot; &lt;&lt; pros::millis() - renderdone &lt;&lt; &quot;ms&quot;
                  &lt;&lt; std::endl;
      }

      lv_obj_invalidate(_canvas);  // force canvas redraw

      auto delay = _gif-&gt;gce.delay * 10;
      auto delta = pros::millis() - now;
      delay -= delta;

      if (delay &gt; 0) pros::delay(delay);
    }

    if (looped == _gif-&gt;loop_count) {
      break;
    }

    gd_rewind(_gif);
  }

  _cleanup();
}

/**
 * Calls _render()
 * @param arg Gif*
 */
void Gif::_render_task(void *arg) {
  Gif *instance = static_cast&lt;Gif *&gt;(arg);
  instance-&gt;_render();
}</code></pre>
<h1>./src/screen/gifdecoder.c</h1>
<p><strong>Last commit:</strong> feat: gifs (2023-11-29)</p>
<pre><code class="language-c line-numbers">
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

#include &quot;gif-pros/gifdec.h&quot;
#ifdef _WIN32
#include &lt;io.h&gt;
#else
#include &lt;unistd.h&gt;
#endif

#define MIN(A, B) ((A) &lt; (B) ? (A) : (B))
#define MAX(A, B) ((A) &gt; (B) ? (A) : (B))

typedef struct Entry {
  uint16_t length;
  uint16_t prefix;
  uint8_t suffix;
} Entry;

typedef struct Table {
  int bulk;
  int nentries;
  Entry *entries;
} Table;

static uint16_t read_num(int fd) {
  uint8_t bytes[2];

  read(fd, bytes, 2);
  return bytes[0] + (((uint16_t)bytes[1]) &lt;&lt; 8);
}

gd_GIF *gd_open_gif(const char *fname) {
  int fd;
  uint8_t sigver[3];
  uint16_t width, height, depth;
  uint8_t fdsz, bgidx, aspect;
  int i;
  uint8_t *bgcolor;
  int gct_sz;
  gd_GIF *gif;

  fd = open(fname, O_RDONLY);
  if (fd == -1) return NULL;
#ifdef _WIN32
  setmode(fd, O_BINARY);
#endif
  /* Header */
  read(fd, sigver, 3);
  if (memcmp(sigver, &quot;GIF&quot;, 3) != 0) {
    fprintf(stderr, &quot;invalid signature\n&quot;);
    goto fail;
  }
  /* Version */
  read(fd, sigver, 3);
  if (memcmp(sigver, &quot;89a&quot;, 3) != 0) {
    fprintf(stderr, &quot;invalid version\n&quot;);
    goto fail;
  }
  /* Width x Height */
  width = read_num(fd);
  height = read_num(fd);
  /* FDSZ */
  read(fd, &amp;fdsz, 1);
  /* Presence of GCT */
  if (!(fdsz &amp; 0x80)) {
    fprintf(stderr, &quot;no global color table\n&quot;);
    goto fail;
  }
  /* Color Space&#39;s Depth */
  depth = ((fdsz &gt;&gt; 4) &amp; 7) + 1;
  /* Ignore Sort Flag. */
  /* GCT Size */
  gct_sz = 1 &lt;&lt; ((fdsz &amp; 0x07) + 1);
  /* Background Color Index */
  read(fd, &amp;bgidx, 1);
  /* Aspect Ratio */
  read(fd, &amp;aspect, 1);
  /* Create gd_GIF Structure. */
  gif = calloc(1, sizeof(*gif));
  if (!gif) goto fail;
  gif-&gt;fd = fd;
  gif-&gt;width = width;
  gif-&gt;height = height;
  gif-&gt;depth = depth;
  /* Read GCT */
  gif-&gt;gct.size = gct_sz;
  read(fd, gif-&gt;gct.colors, 3 * gif-&gt;gct.size);
  gif-&gt;palette = &amp;gif-&gt;gct;
  gif-&gt;bgindex = bgidx;
  gif-&gt;frame = calloc(4, width * height);
  if (!gif-&gt;frame) {
    free(gif);
    goto fail;
  }
  gif-&gt;canvas = &amp;gif-&gt;frame[width * height];
  if (gif-&gt;bgindex) memset(gif-&gt;frame, gif-&gt;bgindex, gif-&gt;width * gif-&gt;height);
  bgcolor = &amp;gif-&gt;palette-&gt;colors[gif-&gt;bgindex * 3];
  if (bgcolor[0] || bgcolor[1] || bgcolor[2])
    for (i = 0; i &lt; gif-&gt;width * gif-&gt;height; i++)
      memcpy(&amp;gif-&gt;canvas[i * 3], bgcolor, 3);
  gif-&gt;anim_start = lseek(fd, 0, SEEK_CUR);
  goto ok;
fail:
  close(fd);
  return 0;
ok:
  return gif;
}

static void discard_sub_blocks(gd_GIF *gif) {
  uint8_t size;

  do {
    read(gif-&gt;fd, &amp;size, 1);
    lseek(gif-&gt;fd, size, SEEK_CUR);
  } while (size);
}

static void read_plain_text_ext(gd_GIF *gif) {
  if (gif-&gt;plain_text) {
    uint16_t tx, ty, tw, th;
    uint8_t cw, ch, fg, bg;
    off_t sub_block;
    lseek(gif-&gt;fd, 1, SEEK_CUR); /* block size = 12 */
    tx = read_num(gif-&gt;fd);
    ty = read_num(gif-&gt;fd);
    tw = read_num(gif-&gt;fd);
    th = read_num(gif-&gt;fd);
    read(gif-&gt;fd, &amp;cw, 1);
    read(gif-&gt;fd, &amp;ch, 1);
    read(gif-&gt;fd, &amp;fg, 1);
    read(gif-&gt;fd, &amp;bg, 1);
    sub_block = lseek(gif-&gt;fd, 0, SEEK_CUR);
    gif-&gt;plain_text(gif, tx, ty, tw, th, cw, ch, fg, bg);
    lseek(gif-&gt;fd, sub_block, SEEK_SET);
  } else {
    /* Discard plain text metadata. */
    lseek(gif-&gt;fd, 13, SEEK_CUR);
  }
  /* Discard plain text sub-blocks. */
  discard_sub_blocks(gif);
}

static void read_graphic_control_ext(gd_GIF *gif) {
  uint8_t rdit;

  /* Discard block size (always 0x04). */
  lseek(gif-&gt;fd, 1, SEEK_CUR);
  read(gif-&gt;fd, &amp;rdit, 1);
  gif-&gt;gce.disposal = (rdit &gt;&gt; 2) &amp; 3;
  gif-&gt;gce.input = rdit &amp; 2;
  gif-&gt;gce.transparency = rdit &amp; 1;
  gif-&gt;gce.delay = read_num(gif-&gt;fd);
  read(gif-&gt;fd, &amp;gif-&gt;gce.tindex, 1);
  /* Skip block terminator. */
  lseek(gif-&gt;fd, 1, SEEK_CUR);
}

static void read_comment_ext(gd_GIF *gif) {
  if (gif-&gt;comment) {
    off_t sub_block = lseek(gif-&gt;fd, 0, SEEK_CUR);
    gif-&gt;comment(gif);
    lseek(gif-&gt;fd, sub_block, SEEK_SET);
  }
  /* Discard comment sub-blocks. */
  discard_sub_blocks(gif);
}

static void read_application_ext(gd_GIF *gif) {
  char app_id[8];
  char app_auth_code[3];

  /* Discard block size (always 0x0B). */
  lseek(gif-&gt;fd, 1, SEEK_CUR);
  /* Application Identifier. */
  read(gif-&gt;fd, app_id, 8);
  /* Application Authentication Code. */
  read(gif-&gt;fd, app_auth_code, 3);
  if (!strncmp(app_id, &quot;NETSCAPE&quot;, sizeof(app_id))) {
    /* Discard block size (0x03) and constant byte (0x01). */
    lseek(gif-&gt;fd, 2, SEEK_CUR);
    gif-&gt;loop_count = read_num(gif-&gt;fd);
    /* Skip block terminator. */
    lseek(gif-&gt;fd, 1, SEEK_CUR);
  } else if (gif-&gt;application) {
    off_t sub_block = lseek(gif-&gt;fd, 0, SEEK_CUR);
    gif-&gt;application(gif, app_id, app_auth_code);
    lseek(gif-&gt;fd, sub_block, SEEK_SET);
    discard_sub_blocks(gif);
  } else {
    discard_sub_blocks(gif);
  }
}

static void read_ext(gd_GIF *gif) {
  uint8_t label;

  read(gif-&gt;fd, &amp;label, 1);
  switch (label) {
    case 0x01:
      read_plain_text_ext(gif);
      break;
    case 0xF9:
      read_graphic_control_ext(gif);
      break;
    case 0xFE:
      read_comment_ext(gif);
      break;
    case 0xFF:
      read_application_ext(gif);
      break;
    default:
      fprintf(stderr, &quot;unknown extension: %02X\n&quot;, label);
  }
}

static Table *new_table(int key_size) {
  int key;
  int init_bulk = MAX(1 &lt;&lt; (key_size + 1), 0x100);
  Table *table = malloc(sizeof(*table) + sizeof(Entry) * init_bulk);
  if (table) {
    table-&gt;bulk = init_bulk;
    table-&gt;nentries = (1 &lt;&lt; key_size) + 2;
    table-&gt;entries = (Entry *)&amp;table[1];
    for (key = 0; key &lt; (1 &lt;&lt; key_size); key++)
      table-&gt;entries[key] = (Entry){1, 0xFFF, key};
  }
  return table;
}

/* Add table entry. Return value:
 *  0 on success
 *  +1 if key size must be incremented after this addition
 *  -1 if could not realloc table */
static int add_entry(Table **tablep, uint16_t length, uint16_t prefix,
                     uint8_t suffix) {
  Table *table = *tablep;
  if (table-&gt;nentries == table-&gt;bulk) {
    table-&gt;bulk *= 2;
    table = realloc(table, sizeof(*table) + sizeof(Entry) * table-&gt;bulk);
    if (!table) return -1;
    table-&gt;entries = (Entry *)&amp;table[1];
    *tablep = table;
  }
  table-&gt;entries[table-&gt;nentries] = (Entry){length, prefix, suffix};
  table-&gt;nentries++;
  if ((table-&gt;nentries &amp; (table-&gt;nentries - 1)) == 0) return 1;
  return 0;
}

static uint16_t get_key(gd_GIF *gif, int key_size, uint8_t *sub_len,
                        uint8_t *shift, uint8_t *byte) {
  int bits_read;
  int rpad;
  int frag_size;
  uint16_t key;

  key = 0;
  for (bits_read = 0; bits_read &lt; key_size; bits_read += frag_size) {
    rpad = (*shift + bits_read) % 8;
    if (rpad == 0) {
      /* Update byte. */
      if (*sub_len == 0) {
        read(gif-&gt;fd, sub_len, 1); /* Must be nonzero! */
        if (*sub_len == 0) return 0x1000;
      }
      read(gif-&gt;fd, byte, 1);
      (*sub_len)--;
    }
    frag_size = MIN(key_size - bits_read, 8 - rpad);
    key |= ((uint16_t)((*byte) &gt;&gt; rpad)) &lt;&lt; bits_read;
  }
  /* Clear extra bits to the left. */
  key &amp;= (1 &lt;&lt; key_size) - 1;
  *shift = (*shift + key_size) % 8;
  return key;
}

/* Compute output index of y-th input line, in frame of height h. */
static int interlaced_line_index(int h, int y) {
  int p; /* number of lines in current pass */

  p = (h - 1) / 8 + 1;
  if (y &lt; p) /* pass 1 */
    return y * 8;
  y -= p;
  p = (h - 5) / 8 + 1;
  if (y &lt; p) /* pass 2 */
    return y * 8 + 4;
  y -= p;
  p = (h - 3) / 4 + 1;
  if (y &lt; p) /* pass 3 */
    return y * 4 + 2;
  y -= p;
  /* pass 4 */
  return y * 2 + 1;
}

/* Decompress image pixels.
 * Return 0 on success or -1 on out-of-memory (w.r.t. LZW code table). */
static int read_image_data(gd_GIF *gif, int interlace) {
  uint8_t sub_len, shift, byte;
  int init_key_size, key_size, table_is_full;
  int frm_off, frm_size, str_len, i, p, x, y;
  uint16_t key, clear, stop;
  int ret;
  Table *table;
  Entry entry;
  off_t start, end;

  read(gif-&gt;fd, &amp;byte, 1);
  key_size = (int)byte;
  if (key_size &lt; 2 || key_size &gt; 8) return -1;

  start = lseek(gif-&gt;fd, 0, SEEK_CUR);
  discard_sub_blocks(gif);
  end = lseek(gif-&gt;fd, 0, SEEK_CUR);
  lseek(gif-&gt;fd, start, SEEK_SET);
  clear = 1 &lt;&lt; key_size;
  stop = clear + 1;
  table = new_table(key_size);
  key_size++;
  init_key_size = key_size;
  sub_len = shift = 0;
  key = get_key(gif, key_size, &amp;sub_len, &amp;shift, &amp;byte); /* clear code */
  frm_off = 0;
  ret = 0;
  frm_size = gif-&gt;fw * gif-&gt;fh;
  while (frm_off &lt; frm_size) {
    if (key == clear) {
      key_size = init_key_size;
      table-&gt;nentries = (1 &lt;&lt; (key_size - 1)) + 2;
      table_is_full = 0;
    } else if (!table_is_full) {
      ret = add_entry(&amp;table, str_len + 1, key, entry.suffix);
      if (ret == -1) {
        free(table);
        return -1;
      }
      if (table-&gt;nentries == 0x1000) {
        ret = 0;
        table_is_full = 1;
      }
    }
    key = get_key(gif, key_size, &amp;sub_len, &amp;shift, &amp;byte);
    if (key == clear) continue;
    if (key == stop || key == 0x1000) break;
    if (ret == 1) key_size++;
    entry = table-&gt;entries[key];
    str_len = entry.length;
    for (i = 0; i &lt; str_len; i++) {
      p = frm_off + entry.length - 1;
      x = p % gif-&gt;fw;
      y = p / gif-&gt;fw;
      if (interlace) y = interlaced_line_index((int)gif-&gt;fh, y);
      gif-&gt;frame[(gif-&gt;fy + y) * gif-&gt;width + gif-&gt;fx + x] = entry.suffix;
      if (entry.prefix == 0xFFF)
        break;
      else
        entry = table-&gt;entries[entry.prefix];
    }
    frm_off += str_len;
    if (key &lt; table-&gt;nentries - 1 &amp;&amp; !table_is_full)
      table-&gt;entries[table-&gt;nentries - 1].suffix = entry.suffix;
  }
  free(table);
  if (key == stop) read(gif-&gt;fd, &amp;sub_len, 1); /* Must be zero! */
  lseek(gif-&gt;fd, end, SEEK_SET);
  return 0;
}

/* Read image.
 * Return 0 on success or -1 on out-of-memory (w.r.t. LZW code table). */
static int read_image(gd_GIF *gif) {
  uint8_t fisrz;
  int interlace;

  /* Image Descriptor. */
  gif-&gt;fx = read_num(gif-&gt;fd);
  gif-&gt;fy = read_num(gif-&gt;fd);

  if (gif-&gt;fx &gt;= gif-&gt;width || gif-&gt;fy &gt;= gif-&gt;height) return -1;

  gif-&gt;fw = read_num(gif-&gt;fd);
  gif-&gt;fh = read_num(gif-&gt;fd);

  gif-&gt;fw = MIN(gif-&gt;fw, gif-&gt;width - gif-&gt;fx);
  gif-&gt;fh = MIN(gif-&gt;fh, gif-&gt;height - gif-&gt;fy);

  read(gif-&gt;fd, &amp;fisrz, 1);
  interlace = fisrz &amp; 0x40;
  /* Ignore Sort Flag. */
  /* Local Color Table? */
  if (fisrz &amp; 0x80) {
    /* Read LCT */
    gif-&gt;lct.size = 1 &lt;&lt; ((fisrz &amp; 0x07) + 1);
    read(gif-&gt;fd, gif-&gt;lct.colors, 3 * gif-&gt;lct.size);
    gif-&gt;palette = &amp;gif-&gt;lct;
  } else
    gif-&gt;palette = &amp;gif-&gt;gct;
  /* Image Data. */
  return read_image_data(gif, interlace);
}

static void render_frame_rect(gd_GIF *gif, uint8_t *buffer) {
  int i, j, k;
  uint8_t index, *color;
  i = gif-&gt;fy * gif-&gt;width + gif-&gt;fx;
  for (j = 0; j &lt; gif-&gt;fh; j++) {
    for (k = 0; k &lt; gif-&gt;fw; k++) {
      index = gif-&gt;frame[(gif-&gt;fy + j) * gif-&gt;width + gif-&gt;fx + k];
      color = &amp;gif-&gt;palette-&gt;colors[index * 3];

      if (!gif-&gt;gce.transparency || index != gif-&gt;gce.tindex)
        memcpy(&amp;buffer[(i + k) * 3], color, 3);
    }
    i += gif-&gt;width;
  }
}

static void dispose(gd_GIF *gif) {
  int i, j, k;
  uint8_t *bgcolor;
  switch (gif-&gt;gce.disposal) {
    case 2: /* Restore to background color. */
      bgcolor = &amp;gif-&gt;palette-&gt;colors[gif-&gt;bgindex * 3];
      i = gif-&gt;fy * gif-&gt;width + gif-&gt;fx;
      for (j = 0; j &lt; gif-&gt;fh; j++) {
        for (k = 0; k &lt; gif-&gt;fw; k++)
          memcpy(&amp;gif-&gt;canvas[(i + k) * 3], bgcolor, 3);
        i += gif-&gt;width;
      }
      break;
    case 3: /* Restore to previous, i.e., don&#39;t update canvas.*/
      break;
    default:
      /* Add frame non-transparent pixels to canvas. */
      render_frame_rect(gif, gif-&gt;canvas);
  }
}

/* Return 1 if got a frame; 0 if got GIF trailer; -1 if error. */
int gd_get_frame(gd_GIF *gif) {
  char sep;

  read(gif-&gt;fd, &amp;sep, 1);
  while (sep != &#39;,&#39;) {
    if (sep == &#39;;&#39;) return 0;
    if (sep == &#39;!&#39;)
      read_ext(gif);
    else
      return -1;
    read(gif-&gt;fd, &amp;sep, 1);
  }
  if (read_image(gif) == -1) return -1;
  return 1;
}

void gd_render_frame(gd_GIF *gif, uint8_t *buffer) {
  memcpy(buffer, gif-&gt;canvas, gif-&gt;width * gif-&gt;height * 3);
  render_frame_rect(gif, buffer);
}

int gd_is_bgcolor(gd_GIF *gif, uint8_t color[3]) {
  return !memcmp(&amp;gif-&gt;palette-&gt;colors[gif-&gt;bgindex * 3], color, 3);
}

void gd_rewind(gd_GIF *gif) { lseek(gif-&gt;fd, gif-&gt;anim_start, SEEK_SET); }

void gd_close_gif(gd_GIF *gif) {
  close(gif-&gt;fd);
  free(gif-&gt;frame);
  free(gif);
}</code></pre>
<h1>./src/screen/screen.hpp</h1>
<p><strong>Last commit:</strong> feat: gifs! and slight cata update (2023-11-28)</p>
<pre><code class="language-cpp line-numbers">
#pragma once
#include &quot;liblvgl/core/lv_obj.h&quot;
#include &quot;liblvgl/widgets/lv_img.h&quot;
#include &quot;main.h&quot;

namespace screen {

/**
 * Class that represents a window on the screen.
 */
class Window {
public:
  Window(int width, int height);
  Window(int width, int height, lv_obj_t *parent);
  ~Window();

  // delete the copy constructor and assignment operator
  Window(const Window &amp;) = delete;
  Window &amp;operator=(const Window &amp;) = delete;

  /**
   * Gets the width of the window.
   *
   * @return The width of the window.
   */
  int getWidth() const;

  /**
   * Gets the height of the window.
   *
   * @return The height of the window.
   */
  int getHeight() const;

  /**
   * Gets the LVGL object that represents this window.
   *
   * @return The LVGL object that represents this window.
   */
  lv_obj_t *getLvObj();

  /**
   * Gets if this window is active
   */
  bool isActive() const;

  /**
   * Sets if this window is active
   */
  void setActive(bool active);

  /**
   * Toggles the active state of this window
   * @return the new active state
   */
  bool toggleActive();

  /**
   * Gets the pros task handle for this window.
   * nullptr if the task is not running.
   */
  pros::Task *getTask() const;

  /**
   * Starts the task for this window.
   */
  void startTask();

  /**
   * Initializes the window.
   */
  virtual void init();

protected:
  /**
   * The width of the window.
   */
  int width;

  /**
   * The height of the window.
   */
  int height;

  /**
   * The LVGL object that represents this window.
   */
  lv_obj_t *lvObj;

  /**
   * The pros task handle for this window.
   */
  pros::Task *task;

  /**
   * If this window is active
   */
  bool active;

  /**
   * The task function for this window.
   */
  virtual void tick();
};

/**
 * Field window class.
 */
class FieldWindow : public Window {
public:
  using Window::Window;

  // overridden functions
  void init() override;

protected:
  // overridden functions
  void tick() override;

private:
  lv_obj_t *fieldImage;
  lv_obj_t *robotImage;
};

/**
 * Game GIF window class.
 */
class GameGifWindow : public Window {
public:
  using Window::Window;

  // overridden functions
  void init() override;

protected:
  // overridden functions
  void tick() override;

private:
  lv_obj_t *gifImage;
};

} // namespace screen</code></pre>
<h1>./src/screen/window.cpp</h1>
<p><strong>Last commit:</strong> fix: it builds! (2023-10-18)</p>
<pre><code class="language-cpp line-numbers">
#include &quot;liblvgl/core/lv_disp.h&quot;
#include &quot;main.h&quot;
#include &quot;screen.hpp&quot;

using namespace screen;

// refresh rate of the screen in milliseconds
const int SCREEN_REFRESH_RATE = 20;

/**
 * Main constructor for a window.
 */
Window::Window(int width, int height, lv_obj_t *parent) {
  this-&gt;width = width;
  this-&gt;height = height;
  this-&gt;active = true;
  this-&gt;lvObj = lv_obj_create(parent);
  lv_obj_set_size(this-&gt;lvObj, width, height);
}

/**
 * Creates a new window with the given width and height and uses the active
 * screen as the parent.
 */
Window::Window(int width, int height) : Window(width, height, lv_scr_act()) {}

/**
 * Frees the LVGL object that represents this window and kills the pros task.
 */
Window::~Window() {
  lv_obj_del(this-&gt;lvObj);

  if (this-&gt;task != nullptr) {
    this-&gt;task-&gt;remove();
    delete this-&gt;task;
  }
}

void Window::startTask() {
  if (this-&gt;task != nullptr) {
    // error - task already started
    throw &quot;Task already started&quot;;
  }

  this-&gt;task = new pros::Task(
      [this]() {
        while (true) {
          this-&gt;tick();
          pros::delay(SCREEN_REFRESH_RATE);
        }
      },
      &quot;Screen Window&quot;);

  // this-&gt;task-&gt;set_priority(SCREEN_TASK_PRIORITY);
}

/**
 * Gets the width of the window.
 *
 * @return The width of the window.
 */
int Window::getWidth() const { return this-&gt;width; }

/**
 * Gets the height of the window.
 *
 * @return The height of the window.
 */
int Window::getHeight() const { return this-&gt;height; }

/**
 * Gets the LVGL object that represents this window.
 *
 * @return The LVGL object that represents this window.
 */
lv_obj_t *Window::getLvObj() { return this-&gt;lvObj; }

/**
 * Gets if this window is active
 */
bool Window::isActive() const { return this-&gt;active; }

/**
 * Sets if this window is active
 */
void Window::setActive(bool active) { this-&gt;active = active; }

/**
 * Toggles the active state of this window
 * @return the new active state
 */
bool Window::toggleActive() {
  this-&gt;active = !this-&gt;active;
  return this-&gt;active;
}

/**
 * Gets the pros task handle for this window.
 * nullptr if the task is not running.
 */
pros::Task *Window::getTask() const { return this-&gt;task; }

// stub
void Window::tick(){};</code></pre>
<h1>./src/subsystems/catapult.cpp</h1>
<p><strong>Last commit:</strong> fix: catapult angles (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#include &lt;memory&gt;

#include &quot;../config.hpp&quot;
#include &quot;subsystems.hpp&quot;

// simple PD controller for the catapult
std::shared_ptr&lt;PIDController&gt; catapult::catapultPID =
    std::make_shared&lt;PIDController&gt;(1, 0, 0.001);

catapult::CatapultState catapult::catapultState = RELOADING;
pros::Task *catapult::catapultTask = nullptr;
bool catapult::rapidFire = false;

/**
 * A simple state machine-like function to handle catapult control.
 * NOTE: The rotational sensor is BACKWARDS, catapult DOWN = DECREASED ANGLE!
 */
void catapult::update() {
  // if we&#39;re ready, do nothing
  // ratchet will keep us in place
  if (catapultState == READY) {
    return;
  }

  // otherwise, calculate error and spin
  double position = (double)catapult_position-&gt;get_angle() / 100;
  double error =
      position &lt; CATAPULT_READY_STATE ? CATAPULT_READY_STATE - position : 360;

  // if error is less than the allowed error, we&#39;re ready
  // rapidFire needs to be false
  if (error &lt; CATAPULT_ALLOWED_ERROR &amp;&amp; catapultState != FIRING &amp;&amp; !rapidFire) {
    catapultState = READY;
    catapult_motor-&gt;move_velocity(0);
    return;
  }

  // reload if error &gt; 20deg
  if (error &gt; 30 &amp;&amp; catapultState == FIRING) catapultState = RELOADING;

  double output = 100;

  catapult_motor-&gt;move_velocity(output);
}

void catapult::fire() {
  // if we&#39;re ready, fire
  if (catapultState == READY) {
    catapult_motor-&gt;move_velocity(100);

    pros::Task([] {
      pros::delay(300);
      catapultState = FIRING;
    });
  }

  printf(&quot;[warn] catapult is not ready to fire! Current state: %d\n&quot;,
         catapultState);
}

void catapult::updateLoop() {
  while (true) {
    update();
    pros::delay(20);
  }
}

void catapult::initialize() {
  if (catapultTask == nullptr) catapultTask = new pros::Task(updateLoop);
}</code></pre>
<h1>./src/subsystems/subsystems.hpp</h1>
<p><strong>Last commit:</strong> fix: catapult angles (2023-11-29)</p>
<pre><code class="language-cpp line-numbers">
#pragma once

#include &lt;memory&gt;

#include &quot;../algorithms/PID.hpp&quot;
#include &quot;pros/rtos.hpp&quot;

/**
 * Catapult-related subsystem functions
 */
namespace catapult {

#define CATAPULT_ALLOWED_ERROR 5
#define CATAPULT_ZERO_ANGLE 262
#define CATAPULT_READY_STATE 220

enum CatapultState { READY, RELOADING, FIRING };
extern CatapultState catapultState;
extern bool rapidFire;

extern std::shared_ptr&lt;PIDController&gt; catapultPID;
extern pros::Task *catapultTask;

/**
 * Ticks the catapult subsystem.
 */
void update();

/**
 * Runs the catapult subsystem.
 * Should be run in a separate pros task, as it is blocking.
 */
void updateLoop();

/**
 * Starts the catapult subsystem.
 */
void initialize();

/**
 * Fires the catapult. Queues if the catapult is not ready.
 */
void fire();

}  // namespace catapult</code></pre>
<h1>./src/subsystems/wings.cpp</h1>
<p><strong>Last commit:</strong> feat: catapult (2023-11-20)</p>
<pre><code class="language-cpp line-numbers">
</code></pre>
<h1>./scripts/htmlify.sh</h1>
<p><strong>Last commit:</strong> header file syntax highlighting (2023-11-28)</p>
<pre><code class="language-bash line-numbers">
#!/bin/bash

# This script converts text files into one HTML file.

# List of files to convert (glob)
FILES=(
  &quot;./README.md&quot;
  &quot;./src/*&quot;
  &quot;./src/**/*&quot;
  &quot;./scripts/*&quot;
)

# Ext override map
EXT_OVERRIDES=(
  &quot;hpp:cpp&quot;
  &quot;sh:bash&quot;
  &quot;h:c&quot;
)

# Output file
OUTPUT=&quot;index.html&quot;

# Header
cat &lt;&lt;EOF &gt; $OUTPUT
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;My Project&lt;/title&gt;

  &lt;!-- PrismJS --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/themes/prism-coy.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.css&quot; /&gt;

  &lt;style&gt;
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 8px;
    }
    pre {
      margin: 0;
    }

    code {
      font-family: monospace;
    }

    h1 {
      margin-top: 1rem;
      margin-bottom: 0.25rem;
    }

    p {
      margin-top: 0.25rem;
      margin-bottom: 0.25rem;
    }

    pre[class*=&quot;language-&quot;] {
      max-height: inherit !important;
      overflow: hidden !important;

      box-shadow: none !important;
      border-left: none !important;
    }

    code[class*=&quot;language&quot;] {
      overflow: hidden !important;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
EOF

# Append each file to the output with a header of file path
for FILE in ${FILES[@]}; do
  # Ignore directories
  if [ -d &quot;$FILE&quot; ]; then
    continue
  fi

  FILE_EXT=&quot;${FILE##*.}&quot;

  # if markdown, convert to html
  if [ &quot;$FILE_EXT&quot; = &quot;md&quot; ]; then
    FILE_EXT=&quot;html&quot;
    FILE=&quot;$FILE&quot;
    pandoc -f markdown -t html $FILE &gt;&gt; $OUTPUT
    echo &quot;&lt;hr&gt;&quot; &gt;&gt; $OUTPUT

    continue
  fi

  # Check if the file extension is overridden
  for OVERRIDE in ${EXT_OVERRIDES[@]}; do
    EXT=${OVERRIDE%:*}
    NEW_EXT=${OVERRIDE#*:}
    if [ &quot;$FILE_EXT&quot; = &quot;$EXT&quot; ]; then
      FILE_EXT=&quot;$NEW_EXT&quot;
    fi
  done

  # Append the title
  echo &quot;&lt;h1&gt;$FILE&lt;/h1&gt;&quot; &gt;&gt; $OUTPUT
  
  # Get the last git commit message and date
  LAST_COMMIT=$(git log -1 --pretty=format:&quot;%s (%ad)&quot; --date=short $FILE)
  echo &quot;&lt;p&gt;&lt;strong&gt;Last commit:&lt;/strong&gt; $LAST_COMMIT&lt;/p&gt;&quot; &gt;&gt; $OUTPUT

  # Append the code
  echo &quot;&lt;pre&gt;&lt;code class=\&quot;language-$FILE_EXT line-numbers\&quot;&gt;&quot; &gt;&gt; $OUTPUT

  cat $FILE | sed &#39;s/&amp;/\&amp;amp;/g; s/&lt;/\&amp;lt;/g; s/&gt;/\&amp;gt;/g; s/&quot;/\&amp;quot;/g; s/&#39;&quot;&#39;&quot;&#39;/\&amp;#39;/g&#39; &gt;&gt; $OUTPUT
  echo &quot;&lt;/code&gt;&lt;/pre&gt;&quot; &gt;&gt; $OUTPUT

  # cat $FILE | sed -e &#39;s/^/    /&#39; | sed -e &#39;s/  / \&amp;nbsp;/&#39; | sed -e &#39;s/$/&lt;br&gt;/&#39; &gt;&gt; $OUTPUT
done

# Footer
cat &lt;&lt;EOF &gt;&gt; $OUTPUT
  &lt;!-- PrismJS --&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js&quot;&gt;&lt;/script&gt; 
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-c.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-cpp.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-bash.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF

</code></pre>
  <!-- PrismJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js"></script> 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>
